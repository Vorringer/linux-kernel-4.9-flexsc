int argu_type[332][6] = {{0, 1, 0, 0, 0, 0},{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 1, 1, 1, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 1, 0, 0, 1, 1},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 0, 0, 1, 1, 0},
{0, 0, 1, 0, 1, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 1, 0, 1, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 1, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 1, 1, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 1, 0},
{0, 0, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 1, 0, 1, 1, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 1, 0, 1, 0},
{1, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 1, 0, 1, 0, 0},
{1, 0, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 1, 1, 1},
{1, 0, 1, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 1, 1, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 1, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0}};


#include <linux/kernel.h>
#include <linux/linkage.h>
#include <linux/kthread.h>
#include <linux/uaccess.h>
#include <linux/string.h>
#include <linux/mman.h>
#include <linux/syscalls.h>
#include <linux/fs.h>
#include <linux/slab.h>

#include <asm/processor.h>

#define MAX_ENTRY (32)
#define SYSCALL_ENTRY_FREE (0)
#define SYSCALL_ENTRY_SUBMITED (1)
#define SYSCALL_ENTRY_DONE (2)
#define SYSCALL_ENTRY_BLOCKED (3)

bool registerd = false;

struct files_struct *saved_files = NULL;

void *temp_mem = NULL;
volatile long flexsc_pid = 0;
struct task_struct *current_flexsc_task = NULL;
struct task_struct *flexsc_task = NULL;
struct task_struct *cache_task = NULL;
void *testaddr = NULL;
int fd = -1;
struct file * mem_file = NULL;

const char *secret_string = "The secret is here.";

extern void *mem_msg_buf;

extern asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,
									  unsigned long prot, unsigned long flags,
									  unsigned long fd, unsigned long pgoff);

struct file *file_open(const char *path, int flags, int rights) 
{
    struct file *filp = NULL;
    mm_segment_t oldfs;
    int err = 0;

    oldfs = get_fs();
    set_fs(get_ds());
    filp = filp_open(path, flags, rights);
    set_fs(oldfs);
    if (IS_ERR(filp)) {
        err = PTR_ERR(filp);
        return NULL;
    }
    return filp;
}


typedef struct {
	int syscall_num;
	short aug_num;
	short status;
	long ret_value;
	long arg0;
	long arg1;
	long arg2;
	long arg3;
	long arg4;
	long arg5;
} Syscall_entry;

typedef long (*sys_call_ptr_t)(long, long, long, long, long, long);

unsigned long mmap_phys_to_virt(unsigned long phys_addr) {
	unsigned long addr;
	if (!mem_file) {
		//fd = sys_open("/dev/mem", O_RDWR | O_SYNC, 0);
		mem_file = file_open("/dev/mem", O_RDWR | O_SYNC, 0);
		if (!mem_file) {
			printk("PHY MEM OPEN FAILED!\n");
			return 0;
		}
	}
	printk("phys_addr: 0x%lx\n", phys_addr);
	//printk("currnet->active_mm: 0x%lx\n", current->active_mm);
	addr = do_mmap(mem_file, 0, 1 << 12, PROT_READ | PROT_WRITE, MAP_SHARED, 0, phys_addr, temp_mem);
	//struct vm_area_struct *vma = find_vma(current->active_mm, temp_mem);
	//remap_pfn_range(vma,vma->vm_start,phys_addr >> PAGE_SHIFT,vma -> vm_end - vma -> vm_start,vma->vm_page_prot);
	//unsigned long addr = 
		//sys_mmap_pgoff(NULL, 1 << PAGE_SHIFT, PROT_READ|PROT_WRITE, MAP_SHARED, fd, phys_addr >> PAGE_SHIFT);
	//addr += phys_addr & ((1 << PAGE_SHIFT) - 1);
	//addr = (unsigned long)temp_mem + (phys_addr & ((1 << PAGE_SHIFT) - 1));
	if (!addr) {
		printk("MMAP PHYS TO VIRT FAILED!\n");
		return 0;
	}
	return addr;
}

int change_mm_and_file(void) {
	if (!current_flexsc_task || !flexsc_task) return -1;
	if (current_flexsc_task->mm == NULL) {
		current_flexsc_task->mm = flexsc_task -> mm;
		saved_files = current -> files;
	}
	current_flexsc_task->files = flexsc_task -> files;
	return 0;
}

int change_back_mm_and_file(void) {
	if (!current_flexsc_task) return -1;
	current_flexsc_task->mm = NULL;
	current_flexsc_task->files = saved_files;
	return 0;
}

unsigned long convert_addr(unsigned long addr) {
	struct task_struct *flexsc_task;
	pgd_t *pgd;
	pte_t *ptep;
	pud_t *pud;
	pmd_t *pmd;
	struct page *page;
	struct mm_struct *mm;
	page = NULL;
	mm = NULL;
	printk("ADDR BEFORE CONVERT: 0x%lx\n", addr);
	printk("FLEXSC_PID: %ld\n", flexsc_pid);
	flexsc_task = find_task_by_vpid(flexsc_pid);
	if (!flexsc_task) {
		printk("TASK NOT FOUND!\n");
		return 0;
	}
	mm = flexsc_task -> mm;
	pgd = pgd_offset(mm, addr);
	if (pgd_none(*pgd) || pgd_bad(*pgd))
	    goto out;
	printk("Valid pgd\n");

	pud = pud_offset(pgd, addr);
	if (pud_none(*pud) || pud_bad(*pud))
	    goto out;
	printk("Valid pud\n");

	pmd = pmd_offset(pud, addr);
	if (pmd_none(*pmd) || pmd_bad(*pmd))
	    goto out;
	printk("Valid pmd\n");

	ptep = pte_offset_map(pmd, addr);
	if (!ptep)
	    goto out;

	addr = ptep->pte & PTE_PFN_MASK;
	pte_unmap(ptep);
	addr = mmap_phys_to_virt(addr);
	//addr = phys_to_virt(addr);
	printk("ADDR AFTER CONVERT: 0x%lx\n", addr);
	return addr;
out:
	printk("ERROR IN WALK!\n");
	return 0;
}

int fill_in_cache(void *addr) {
	while (!kthread_should_stop()) {
		volatile long dummy = 0, i;
		char *secret_addr = (char *)addr;
		for (i = 0; i < 30; i++) {
			dummy += secret_addr[i];
		}
		if (kthread_should_stop()) break;
		schedule();
	}
	return 0;
}

int do_syscall(void *addr) {
	int i;
	int j;
	Syscall_entry *syscall_page; 
	extern const sys_call_ptr_t sys_call_table[];
	syscall_page = (Syscall_entry *) addr;
	while (!kthread_should_stop()) {
		for (i = 0; i < MAX_ENTRY; ++i) {
			if (syscall_page[i].status == SYSCALL_ENTRY_SUBMITED) {
				long ret;
				/*
				printk("REAL! Num: %d, Arguments: %ld, %ld, %ld, %ld, %ld, %ld\n",
					syscall_page[i].syscall_num,
					syscall_page[i].arg0,
					syscall_page[i].arg1,
					syscall_page[i].arg2,
					syscall_page[i].arg3,
					syscall_page[i].arg4,
					syscall_page[i].arg5);
					*/
				preempt_disable();
				/*
				for (j = 0; j < 6; j++) {
					if (argu_type[syscall_page[i].syscall_num][j] == 1) {
						//*(unsigned long *)((void *)syscall_page + (i << 6) + 16 + (j << 3)) = 
							//convert_addr(*(unsigned long *)((void *)syscall_page + (i << 6) + 16 + (j << 3)));
						break;
					}
				}
				*/
				change_mm_and_file();
				atomic_inc(&current_flexsc_task->mm->mm_count);
				ret = sys_call_table[syscall_page[i].syscall_num](syscall_page[i].arg0,
																  syscall_page[i].arg1,
																  syscall_page[i].arg2,
																  syscall_page[i].arg3,
																  syscall_page[i].arg4,
																  syscall_page[i].arg5);

				syscall_page[i].ret_value = ret;
				syscall_page[i].status = SYSCALL_ENTRY_DONE;
				change_back_mm_and_file();
				if (current_flexsc_task && current_flexsc_task -> mm) atomic_dec(&current_flexsc_task -> mm ->mm_count);
				//printk("REAL ret value: %ld\n", ret);
			    preempt_enable();
			}
		}
		if (kthread_should_stop()) {
	        break;
	    }
		//set_current_state(TASK_INTERRUPTIBLE);
		schedule();
	}
	current -> mm = NULL;
	current -> files = saved_files;
	return 0;
}

asmlinkage long sys_flexsc_register(long pid) {
	if (registerd) return 0;
	int i;
	Syscall_entry *syscall_page = mem_msg_buf;
	/*
	printk("DUMP SHARE MEMORY!\n");
	for (i = 0; i < MAX_ENTRY; ++i) {
			printk("%d, %ld, %ld, %ld, %ld, %ld, %ld, %d\n",
					syscall_page[i].syscall_num,
					syscall_page[i].arg0,
					syscall_page[i].arg1,
					syscall_page[i].arg2,
					syscall_page[i].arg3,
					syscall_page[i].arg4,
					syscall_page[i].arg5,
					(int)syscall_page[i].status);
	}
	*/
	current_flexsc_task = kthread_create(&do_syscall, (void *)syscall_page, "flex: ");
	kthread_bind(current_flexsc_task, 1);
	wake_up_process(current_flexsc_task);
	flexsc_pid = pid;
	flexsc_task = find_task_by_vpid(flexsc_pid);
	registerd = true;
	if (!current_flexsc_task) return -2;
/*
	Syscall_entry *syscall_page = (Syscall_entry *) kmalloc(MAX_ENTRY * sizeof(Syscall_entry), GFP_KERNEL);
	memset(syscall_page, 0, MAX_ENTRY * sizeof(Syscall_entry));
	unsigned long ret = copy_from_user(syscall_page, addr, MAX_ENTRY * sizeof(Syscall_entry));
	struct task_struct *task = kthread_run(&do_syscall, (void *)syscall_page, "flex: ");
	if (!task) return -1;
	*/
	return 0;
}

asmlinkage long sys_flexsc_cancel(void) {
	if (current_flexsc_task) {
		 kthread_stop(current_flexsc_task);
		 current_flexsc_task = NULL;
		 registerd = false;
		 flexsc_pid = 0;
		 //printk("FLEXSC THREAD STOPPED!");
	}
	if (cache_task) {
		kthread_stop(cache_task);
		cache_task = NULL;
	}
	return 0;
}

asmlinkage long sys_flexsc_mtest(long len) {
	//printk("IN MTEST");
	if (len > PAGE_OFFSET / 3) {
		return -1;
	}
	if (testaddr) {
		kfree(testaddr);
		testaddr = NULL;
	}
	if (len == 0) return 0;
	testaddr = kmalloc(len, GFP_KERNEL);
	memset(testaddr, 0, len);
	memcpy(testaddr, secret_string, strlen(secret_string));
	cache_task = kthread_create(&fill_in_cache, testaddr, "fill cache: ");
	kthread_bind(cache_task, 1);
	wake_up_process(cache_task);
	printk("TEST ADDR: 0x%lx\n", (unsigned long)testaddr);
	return virt_to_phys(testaddr);
}