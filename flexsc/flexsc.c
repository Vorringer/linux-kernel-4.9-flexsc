int argu_type[332][6] = {{0, 1, 0, 0, 0, 0},{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 1, 1, 1, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 1, 0, 0, 1, 1},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 0, 0, 1, 1, 0},
{0, 0, 1, 0, 1, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 1, 0, 1, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 1, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 1, 1, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 1, 0},
{0, 0, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{1, 1, 0, 0, 0, 0},
{1, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 1, 0, 1, 1, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 0, 1, 0, 0, 0},
{0, 0, 1, 0, 1, 0},
{1, 1, 1, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 1, 0, 1, 0, 0},
{1, 0, 1, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 1, 1, 1},
{1, 0, 1, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 1, 1, 1, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 1, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 1, 0},
{0, 0, 1, 1, 0, 0},
{0, 1, 1, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{1, 1, 1, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 0, 1, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{1, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 1, 1, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 1, 0, 1, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 1, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0},
{0, 0, 0, 0, 0, 0}};


#include <linux/kernel.h>
#include <linux/linkage.h>
#include <linux/kthread.h>
#include <linux/uaccess.h>
#include <linux/string.h>
#include <linux/mman.h>
#include <linux/syscalls.h>
#include <linux/fs.h>
#include <linux/slab.h>

#include <asm/processor.h>

#define MAX_ENTRY (64)
#define SYSCALL_ENTRY_FREE (0)
#define SYSCALL_ENTRY_SUBMITED (1)
#define SYSCALL_ENTRY_DONE (2)
#define SYSCALL_ENTRY_BLOCKED (3)

bool registerd = false;

void *temp_mem = NULL;
volatile long flexsc_pid = 0;

int fd = -1;
struct file * mem_file = NULL;

extern void *mem_msg_buf;

extern asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,
									  unsigned long prot, unsigned long flags,
									  unsigned long fd, unsigned long pgoff);

struct file *file_open(const char *path, int flags, int rights) 
{
    struct file *filp = NULL;
    mm_segment_t oldfs;
    int err = 0;

    oldfs = get_fs();
    set_fs(get_ds());
    filp = filp_open(path, flags, rights);
    set_fs(oldfs);
    if (IS_ERR(filp)) {
        err = PTR_ERR(filp);
        return NULL;
    }
    return filp;
}

struct task_struct *task = NULL;

typedef struct {
	int syscall_num;
	short aug_num;
	short status;
	long ret_value;
	long arg0;
	long arg1;
	long arg2;
	long arg3;
	long arg4;
	long arg5;
} Syscall_entry;

typedef long (*sys_call_ptr_t)(long, long, long, long, long, long);

unsigned long mmap_phys_to_virt(unsigned long phys_addr) {
	unsigned long addr;
	if (!mem_file) {
		//fd = sys_open("/dev/mem", O_RDWR | O_SYNC, 0);
		mem_file = file_open("/dev/mem", O_RDWR | O_SYNC, 0);
		if (!mem_file) {
			printk("PHY MEM OPEN FAILED!\n");
			return 0;
		}
	}
	printk("phys_addr: 0x%lx\n", phys_addr);
	printk("currnet->active_mm: 0x%lx\n", current->active_mm);
	addr = do_mmap(mem_file, 0, 1 << 12, PROT_READ | PROT_WRITE, MAP_SHARED, 0, phys_addr, temp_mem);
	//struct vm_area_struct *vma = find_vma(current->active_mm, temp_mem);
	//remap_pfn_range(vma,vma->vm_start,phys_addr >> PAGE_SHIFT,vma -> vm_end - vma -> vm_start,vma->vm_page_prot);
	//unsigned long addr = 
		//sys_mmap_pgoff(NULL, 1 << PAGE_SHIFT, PROT_READ|PROT_WRITE, MAP_SHARED, fd, phys_addr >> PAGE_SHIFT);
	//addr += phys_addr & ((1 << PAGE_SHIFT) - 1);
	//addr = (unsigned long)temp_mem + (phys_addr & ((1 << PAGE_SHIFT) - 1));
	if (!addr) {
		printk("MMAP PHYS TO VIRT FAILED!\n");
		return 0;
	}
	return addr;
}

int change_mm(void) {
	if (current->mm == NULL) current->mm = find_task_by_vpid(flexsc_pid) -> mm;
	return 0;
}

unsigned long convert_addr(unsigned long addr) {
	struct task_struct *flexsc_task;
	pgd_t *pgd;
	pte_t *ptep;
	pud_t *pud;
	pmd_t *pmd;
	struct page *page;
	struct mm_struct *mm;
	page = NULL;
	mm = NULL;
	printk("ADDR BEFORE CONVERT: 0x%lx\n", addr);
	printk("FLEXSC_PID: %ld\n", flexsc_pid);
	flexsc_task = find_task_by_vpid(flexsc_pid);
	if (!flexsc_task) {
		printk("TASK NOT FOUND!\n");
		return 0;
	}
	mm = flexsc_task -> mm;
	pgd = pgd_offset(mm, addr);
	if (pgd_none(*pgd) || pgd_bad(*pgd))
	    goto out;
	printk("Valid pgd\n");

	pud = pud_offset(pgd, addr);
	if (pud_none(*pud) || pud_bad(*pud))
	    goto out;
	printk("Valid pud\n");

	pmd = pmd_offset(pud, addr);
	if (pmd_none(*pmd) || pmd_bad(*pmd))
	    goto out;
	printk("Valid pmd\n");

	ptep = pte_offset_map(pmd, addr);
	if (!ptep)
	    goto out;

	addr = ptep->pte & PTE_PFN_MASK;
	pte_unmap(ptep);
	addr = mmap_phys_to_virt(addr);
	//addr = phys_to_virt(addr);
	printk("ADDR AFTER CONVERT: 0x%lx\n", addr);
	return addr;
out:
	printk("ERROR IN WALK!\n");
	return 0;
}


int do_syscall(void *addr) {
	Syscall_entry *syscall_page; 
	syscall_page = (Syscall_entry *) addr;
	while (!kthread_should_stop()) {
		int i, j;
		for (i = 0; i < MAX_ENTRY; ++i) {
			if (syscall_page[i].status == SYSCALL_ENTRY_SUBMITED) {
				long ret;
				printk("REAL! Num: %d, Arguments: %ld, %ld, %ld, %ld, %ld, %ld\n",
					syscall_page[i].syscall_num,
					syscall_page[i].arg0,
					syscall_page[i].arg1,
					syscall_page[i].arg2,
					syscall_page[i].arg3,
					syscall_page[i].arg4,
					syscall_page[i].arg5);
/*
				for (j = 0; j < 6; j++) {
					if (argu_type[syscall_page[i].syscall_num][j] == 1) {
						*(unsigned long *)((void *)syscall_page + (i << 6) + 16 + (j << 3)) = 
							convert_addr(*(unsigned long *)((void *)syscall_page + (i << 6) + 16 + (j << 3)));
					}
				}
*/
				change_mm();
				extern const sys_call_ptr_t sys_call_table[];
				ret = sys_call_table[syscall_page[i].syscall_num](syscall_page[i].arg0,
																  syscall_page[i].arg1,
																  syscall_page[i].arg2,
																  syscall_page[i].arg3,
																  syscall_page[i].arg4,
																  syscall_page[i].arg5);
		
				syscall_page[i].ret_value = ret;
				syscall_page[i].status = SYSCALL_ENTRY_DONE;
				printk("REAL ret value: %ld\n", ret);
			}
		}
		schedule();
	}
	return 0;
}

asmlinkage long sys_flexsc_register(long pid) {
	if (registerd) return 0;
	int i;
	Syscall_entry *syscall_page = mem_msg_buf;
	printk("DUMP SHARE MEMORY!\n");
	for (i = 0; i < MAX_ENTRY; ++i) {

			printk("%d, %ld, %ld, %ld, %ld, %ld, %ld, %d\n",
					syscall_page[i].syscall_num,
					syscall_page[i].arg0,
					syscall_page[i].arg1,
					syscall_page[i].arg2,
					syscall_page[i].arg3,
					syscall_page[i].arg4,
					syscall_page[i].arg5,
					(int)syscall_page[i].status);
	}
	if (!temp_mem) {
		temp_mem = kmalloc(1 << PAGE_SHIFT, GFP_KERNEL);
	}
	task = kthread_create(&do_syscall, (void *)syscall_page, "flex: ");
	//kthread_bind(task, 2);
	wake_up_process(task);
	flexsc_pid = pid;
	registerd = true;
	if (!task) return -2;
/*
	Syscall_entry *syscall_page = (Syscall_entry *) kmalloc(MAX_ENTRY * sizeof(Syscall_entry), GFP_KERNEL);
	memset(syscall_page, 0, MAX_ENTRY * sizeof(Syscall_entry));
	unsigned long ret = copy_from_user(syscall_page, addr, MAX_ENTRY * sizeof(Syscall_entry));
	struct task_struct *task = kthread_run(&do_syscall, (void *)syscall_page, "flex: ");
	if (!task) return -1;
	*/
	return 0;
}

asmlinkage long sys_flexsc_cancel(void) {
	if (task) {
		 kthread_stop(task);
		 task = NULL;
		 registerd = false;
		 flexsc_pid = 0;
		 printk("FLEXSC THREAD STOPPED!");
	}
	return 0;
}
